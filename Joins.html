<html>
  <head>
    <style>
      .Portal {
        border-color: lightblue;
        border-style: solid;
      }
    </style>
  </head>
  <body>
    <h1>
      Joins
    </h1>
    <br/>
    <ul>
        <li>Referential Join
            <ul>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/Q2nFLOtl1VuGglPnaxd2qFngSxpdb9lQglBhocfhby8B9RJKPDZ6AncVoUSkZvuCQe7mGC1ZZIQ2xng6R1SLv3CjzgE9bWsjHbtxri63DQ-IPZ6GT2NWAMVzmTaqkaE-.png" width="455" height="238.752688172043"/></li>
                <li>In Join node when you connect one table to other. Click on the link between the tables ⇒ general properties ⇒ Select Referential Join</li>
                <li>A <b>Referential Join</b> in SAP HANA is a type of join used in calculation views when there is a logical relationship between two tables, typically where one table contains a foreign key referencing a primary key in another table. This type of join is optimized for performance because it assumes that the joined data is always consistent, meaning every foreign key in the referencing table corresponds to a valid primary key in the referenced table.</li>
                <li><b>Default Behavior</b>: If no fields from the right table (referenced table) are requested in the query, the join can be completely skipped, further improving performance.</li>
                <li><b>Output Handling</b>: If fields from the right table are required, the join behaves like an inner join.</li>
                <li>Cardinality must be specified. If it is not, the Referential Join cannot be optimized.</li>
                <li>A referential join can be implemented in a standard join node as well as a star join node.</li>
                <li>Consider two tables:</li>
                <li><b>Orders</b> (OrderID, CustomerID, OrderDate)</li>
                <li><b>Customers</b> (CustomerID, CustomerName, Country)</li>
                <li>The <b>CustomerID</b> in the Orders table is a foreign key referencing the primary key <b>CustomerID</b> in the Customers table.</li>
                <li><pre ><code >SELECT O.OrderID, C.CustomerName, C.Country
FROM Orders O
REFERENTIAL JOIN Customers C
ON O.CustomerID = C.CustomerID;</code></pre></li>
                <li>If the query requests only fields from the <q>Orders</q> table:</li>
                <li><pre ><code >SELECT O.OrderID
FROM Orders O
REFERENTIAL JOIN Customers C
ON O.CustomerID = C.CustomerID;</code></pre> </li>
                <li>The referential join is skipped entirely, and only data from <q>Orders</q> is returned because fields from <q>Customers</q> are not needed.</li>
                <li>Conditions for Referential Join Optimization
                    <ul>
                        <li>A join defined as a Referential Join between two tables or sources, A and B, is pruned (not executed) when all three following conditions are met:</li>
                        <li>No field is requested from B</li>
                        <li>Integrity is placed on A</li>
                        <li>The cardinality on the B side is ..1</li>
                        <li>When the cardinality on the B side is not ..1, the join will always be executed, even if no column from B is requested.</li>
                    </ul>
                </li>
                <li>Integrity Constraint
                    <ul>
                        <li>This setting defines in which direction the referential integrity is guaranteed.</li>
                        <li>Left: Every entry in left table has at least one match in right table. N..1</li>
                        <li>Right: Every entry in right table has at least one match in left table. 1..N</li>
                        <li>Both: Every entry in both tables has at least one match in the other table. 1..1</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Inner Join
            <ul>
                <li>It returns rows when there is at least one match on both sides of the join.  </li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/doUITP9onjun_0p_Injh5BrCVTNKO7gOyKLQyM4UGB3OqNs_3sDXyVr2tSKIYGxYPDz-d5KrMC865IMBVrVhRhz3YQ9fx9kmh-EM0HJwWNt4HUkC1HijpxbSeR7TaFwY.png" width="375" height="210.3896103896104"/> </li>
            </ul>
        </li>
        <li>Left Outer Join
            <ul>
                <li>A Join returns all rows from the left table, even if there are no matches in the right table.</li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/F_XXkBQhESD6rm3oAw1nuREt3adqnRX1ylqVayfo3A9tjyYDdeKQSQD7qwr2_31kc50YZUE6En_13dwVy37pPlaA1yDsKE6PqEDwD9De73dsj9P6yggPi-660B3O822Y.png" width="375" height="211.36363636363637"/></li>
                <li>Try to use N..1 and 1..1 joint cardinality ⇒ Optimal Performance</li>
                <li>Try to reduce number of joint fields</li>
                <li>Avoid joining on calculated columns</li>
                <li>Avoid type conversions at runtime</li>
            </ul>
        </li>
        <li>Right Outer Join
            <ul>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/hWPou30rSNueYSstElcAzmsX55uhiAXK5wUi4q-8UGgKk-EXE_lzdmcMmeiRz4sNKr29vjp_1sQtDpiW2mOE8wQJaVnppPgQpeVEJx3LiUh7CeHLEuwWM1CHI6X6UFnL.png" width="375" height="215.25974025974025"/></li>
                <li>Try to use 1..N and 1..1 joint cardinality ⇒ Optimal Performance</li>
                <li>Try to reduce number of joint fields</li>
                <li>Avoid joining on calculated columns</li>
                <li>Avoid type conversions at runtime</li>
            </ul>
        </li>
        <li>Spatial Join
            <ul>
                <li>Create joins to query data from data sources that have spatial data.</li>
                <li><b>Point</b> – Represents a specific location on Earth (latitude and longitude).</li>
                <li>Example: <q>POINT(12.9715987 77.5945627) =&gt;</q>Bangalore location.</li>
                <li>You can insert POLYGON(latitude, longitude) - https://arthur-e.github.io/Wicket/sandbox-gmaps3.html </li>
                <li><b>Example:</b></li>
                <li>Table A contains customer locations as POINT data (latitude, longitude).</li>
                <li>Table B contains city boundaries as POLYGON data.</li>
                <li>A spatial join helps you find which customer belongs to which city by comparing the POINT to the POLYGON.</li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/ImRM3gPvF8BLO5HqeiOfvEl_-xpzX13fF2D4Zg51GjVr-Zq7UAZa9vX2QYHfzjQDwALoxVEMNuThyfG9UOILFYAV7PTlXYemKJR7-YhnLzI9Oh7QFFgieMVdaFjyHWGx.png" width="1029" height="500.13955726660254"/></li>
                <li>You use the regular join node in a calculation view to create spatial joins by joining two database tables on columns of spatial data types.  </li>
                <li>In any regular join node ⇒ select the join ⇒ You can see spatial properties below the general properties</li>
                <li>In the <b>Spatial</b> <b>Join</b> section, define the spatial join properties.  </li>
                <li>Select predicate ⇒ equals</li>
                <li>Select predicate ⇒ Relate
                    <ul>
                        <li>If you select as the predicate value, in the <b>Intersection Matrix</b> text field enter the required values.</li>
                        <li><b>Example:</b></li>
                        <li>Table A ⇒ Contains customer locations (as POINT).</li>
                        <li>Table B ⇒ Contains city boundaries (as POLYGON).</li>
                        <li>If you want to check whether a customer’s location is exactly <b>inside the city boundary</b> or <b>touching</b> the boundary, you can define a specific Intersection Matrix.</li>
                        <li>SELECT a.customer_id, b.city_name
FROM customer_locations a
JOIN city_boundaries b
ON ST_Relate(a.location, b.boundary, &#39;T*F***FF*&#39;);</li>
                        <li>&#39;T*F***FF*&#39; means:</li>
                        <li>T ⇒ Touching</li>
                        <li>F ⇒ False (no overlap)</li>
                        <li>star ⇒ Ignore</li>
                    </ul>
                </li>
                <li>Select predicate ⇒ Within Distance
                    <ul>
                        <li>if you select  as the predicate value, in the <b>Distance</b> field, select a value. You can provide the distance as a fixed value or use an input parameter to provide the distance value at runtime.</li>
                        <li>This predicate checks if two objects are within a certain distance of each other.  </li>
                        <li>Table A ⇒ Contains customer locations (as POINT).</li>
                        <li>Table B ⇒ Contains store locations (as POINT).</li>
                        <li>If you want to find which customers are within <b>5 kilometers</b> of a store:</li>
                        <li>SELECT a.customer_id, b.store_name
FROM customer_locations a
JOIN store_locations b
ON ST_Within_Distance(a.location, b.location, 5000); -- 5000 meters = 5 km</li>
                        <li>This will return all customers whose location is within 5 km of a store location  </li>
                    </ul>
                </li>
                <li>Select Execute Join if ⇒ Predicate Evaluates to true</li>
                <li>Choose <b>OK</b>.</li>
            </ul>
        </li>
        <li>Full Outer Join
            <ul>
                <li>A Full Outer Join combines the behaviours of the Left and Right Outer Joins.</li>
                <li>Rows from both tables that match on joined columns</li>
                <li>Rows from the left table with no match in the right table</li>
                <li>Rows from the right table with no match in the left table</li>
                <li>A Full Outer Join is supported by calculation views only, in the standard Join and Star Join nodes.</li>
                <li>However, in a Star Join node, a full outer join can only be defined on one DIMENSION calculation view. This view must appear last in the <i>Star Join</i> node.  </li>
            </ul>
        </li>
        <li>Text Join
            <ul>
                <li>a Text Join behaves like a Left Outer Join, with cardinality 1:1 but, in addition, you specify a language column,  </li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/WhG710xduZGDTS1zf9J9Tc5zRczh7N-k_aC6L_u3dn5bzP6FSGjdGFslcMJjVHwFrwUILLtTdBXFP6vE99uG_zJkM3_UrTLbOLeKH_lBxf3CMRRpKcBtthIfMgvu0izD.png" width="1140" height="448.0695652173913"/></li>
                <li>During join execution, the language of the end user querying the calculation view is used to retrieve descriptions from the text table (here, <i>MAKT</i>) in the corresponding language, based on the language column.  </li>
                <li>Then in semantics ⇒ <a isRemReference="true" href="../SAP%20HANA/Nodes/Semantics%20node/Label%20Column%20Field.html?isPin=false">Label Column Field</a></li>
            </ul>
        </li>
        <li>Temporal Join
            <ul>
                <li>Frequently, master data stores historical values. For example, in the employee table there might be two records for one employee. One record represents the employees job position in the past, and the second record represents the employees job position today. Each record contains dates to represent the validity of the record. So how does a calculation view know which record to request?</li>
                <li>It is possible to add a ? condition to a join in order to find matching records from two tables based on a date. The records are only matched if a date column of one table is within a time interval defined by two columns of the other table.</li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/cJ9Kd3oSX4L28m4uiX-kRd1h6wtsXyyS3-OJR2mT4Kar0c7Z_uLapLm66DgnZVy5EyK8c78PAv4oDgIeeLlRkqWTyH7Q0WDPrflPHkwVUuxIOo_VHOqsPnwznkDRO25D.png" width="1140" height="693.9130434782609"/></li>
                <li>In this example, the status of the customers can change over time, and this information is captured in a dedicated table (Customer Status). If you need to analyse the sales orders and include the status of each customer when they issued the order, you create an Inner Join on the <i>ContactID</i> column and add a temporal condition as follows:</li>
                <li>Temporal column ⇒ Date (Sales Orders)</li>
                <li>From Column ⇒ DateFrom (Customer Status)</li>
                <li>To Column ⇒ DateTo (Customer Status)</li>
                <li><a isInlineLink="true" href="https://help.sap.com/docs/SAP_HANA_PLATFORM/fc5ace7a367c434190a8047881f92ed8/fa8abcc4cc094d6faef77c11cd516868.html">Temporal Condition</a> ⇒ Include Both ⇒ determining whether the boundaries are inclusive or exclusive.  </li>
                <li>Only supported in the <i>Star Join</i> of calculation views of the type cube with star join. The join type must be defined as <i>Inner</i>.</li>
                <li>Only columns already mapped to the output of the <i>Star Join</i> node can be defined as <i>Temporal Columns</i> in the temporal properties of the join.</li>
                <li><b>Temporal conditions can be defined on columns of the following data types:</b> 
                    <ul>
                        <li>timestamp</li>
                        <li>date</li>
                        <li>integer</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Join Cardinality
            <ul>
                <li>The cardinality of a join defines how the data from two tables joined together are related, in terms of matching rows.</li>
                <li>For example, if you join the Sales Order table (left table) with the Customer table (right table), you can define an n:1 cardinality. This cardinality means that several sales orders can be related to the same customer, but the opposite is not possible (you cannot have a sales orders that relates to several customers).</li>
                <li>We recommend that you specify the cardinality only when you are sure of the content of the tables. If not, just leave the cardinality blank.</li>
                <li>That is, 1..1, 1..n, n..1, and n..m.</li>
                <li>Always set join cardinalities so the optimizer can decide if joins can be omitted at runtime based on the query that is being sent to the calculation view.</li>
                <li>If tables are used as the data sources, and not calculation views, then you can use the <i>Propose Cardinality</i> option.  </li>
            </ul>
        </li>
        <li>Non-Equi Join
            <ul>
                <li>The join condition is not represented by an = (equal) operator. but instead is based on other comparison operators such as Greater than.</li>
                <li>Operator ⇒ The condition of Join is other than Equal eg. Less than, Greater than, Less than equal to, Not Equal</li>
                <li>Defining a Non-Equi Join condition is possible for the following types of joins: Inner, Left Outer, Right Outer, Full Outer</li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/XZTX9P7syQ8ksKFWG5hxElU31N_SNMZRuTlOb7HngfQF0iW4RXTmX5fJD9YWUt3HK9w4rKjtPgxCiq4w5CgtQUnqBr-OVM4JI7V_1MdFCisdmxNk29Cj8Ss9pTGZcEDt.png" width="479" height="324.2310838445808"/></li>
                <li>ProductsToBeDelivered.id Equal SUBTASKS.id</li>
                <li>ProductsToBeDelivered.dueOn Less Than SUBTASKS.plannedDate</li>
            </ul>
        </li>
        <li>Dynamic Join
            <ul>
                <li>In some scenarios, you want to allow data analysis at different levels of granularity with the same calculation view.</li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/Umj9bk6gtmf3O0QJgZAiHMoeKQdDOpgdVAsGTwWlOH71txlYPJlGriWzG4wgH29W64Zyh7TJVjdvaUtjKPBG4ohosMY-LwvPQZrMXXhmU1SVr5tupZFXNXjJeNL-3fuw.png" width="479" height="344.80163599182004"/></li>
                <li>In this case, assuming that you model your calculation view with a Regular Join on <i>Country</i> and <i>Region</i>, you will get correct results if you analyze the data by country, but the results will be inconsistent if you analyze the data by region.  </li>
                <li>With this Join, only the join columns requested in the query are brought into context and play a part in the join execution. As a consequence, the same calculation view can be used for both purposes, that is, to analyze data by country or by region.  </li>
                <li>A Join can be defined only with multi-column joins. </li>
                <li>With this Join, if none of the joined columns are requested by the client query, you get a query runtime error.  </li>
                <li>If we consider the behavior of the join from an aggregation perspective:
                    <ul>
                        <li>In a Regular (static) Join, the aggregation is executed after the join.</li>
                        <li>In a Dynamic Join, when a joined column is not requested by the client query, an aggregation is triggered to remove this column. Then, the join is executed based only on the requested columns.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Adding a Filter to a Join Node
            <ul>
                <li>When you define a filter (a filter expression) in a join node, you have a possibility to optimize the runtime execution of the calculation view. With filter mapping, when a filter is defined on a column from one source, you can ask the SQL optimizer to also apply this filter to a column of another other source.</li>
                <li>From SAP HANA Cloud QRC 4/2023, it is also possible to define filter mapping in non-equi joins.</li>
                <li>The improved performance results from the early execution of filters on both sources, before the join is executed.  </li>
                <li><img src="https://remnote-user-data.s3.amazonaws.com/2IJ6IkyS2S-YIjm7VRUokM1Yhj-3_RcKHw7iEsdRGFYd-aCit6kyRN0eb-Ahs0Mv_2oG4uHyz5SVhfGDNo_zWrqFnIhkaPtmkEJohAZDQAL38tg00ckX6HvdqtUs3zR8.png" width="479" height="245.8670756646217"/></li>
                <li>A <i>Direction</i> must also be specified, so that the optimizer knows from which side (left or right) an existing filter must be mapped to the other side. The default direction is <i>Left and Right</i>, that is, bi-directional  </li>
                <li>Left ⇒ Right : If Projection_1.product = &#39;Apple&#39;, only records with Projection_2.product_name = &#39;Apple&#39; will be considered in the join.</li>
                <li>Right ⇒ Left: If Projection_2.product_name = &#39;Orange&#39;, only records with Projection_1.product = &#39;Orange&#39; will be considered in the join.</li>
                <li>Left and Right : If <q>Projection_1.product = &#39;Apple&#39;</q> and <q>Projection_2.product_name = &#39;Apple&#39;</q>, the join will work.  If one side doesn’t match, the row gets excluded.</li>
            </ul>
        </li>
        <li>Joining Multiple Data Source in a Join Node
            <ul>
                <li>Support in cube with star join</li>
                <li>In the Join definition select the canvas</li>
                <li>Select the central table</li>
                <li>Select the Multi Join Order
                    <ul>
                        <li>Inside Out ⇒  The join that is near to the central table is executed first</li>
                        <li>Outside In ⇒ The join that is far from the central table is executed first</li>
                        <li><img src="https://remnote-user-data.s3.amazonaws.com/pyjWQT34xS5vgSGxMBQK8K0AL_6DlACNfriulD3jVCGSgTCu6klrURKxFChdRUKMHHXNhYSqbnJ4ywdyuhqd8U6ubzTv9adGNLinN4TVUIIjtn1YNoXN26aMpM60IETE.png" width="468.0000305175781" height="380.9080002985606"/></li>
                        <li><img src="https://remnote-user-data.s3.amazonaws.com/hpOVXKVk3OWOBrFGu3W6rSEzX4PXNYrsIxv223_BIqorBpIn8KZc8y1FAg-DzOLJG1X7-MEvNrtgPd3DgQBwHB5GCPW7i_Rf8OYtFiWkmhN7F4Z3piHOBPWnA-43je8u.png" width="479" height="248.80572597137015"/></li>
                        <li>In the figure, Multi-Join Scenarios, the multi-join order property only applies in scenarios 1 and 2, and affects joins J1 and J2. The precedence between joins J1 and J3 (in scenario 2) or J1 and J2 (in scenario 3) is not controlled by the multi-join order setting.  </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li></li>

    </ul>
    </body>
</html>
